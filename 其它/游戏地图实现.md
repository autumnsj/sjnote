一、程序技术篇：算法和架构（Programming Algorithms & Architecture）

1. 无限循环的平铺地图（Infinite Tiling）

我们就从最平淡无奇的无限循环平铺地图说起吧。这应该是最原始，也是最没有技术含量的开放

世界构筑方式了。

技术上由于过于朴素，也没什么好说的，就是在同一个坐标系内像铺地砖那样展开，坐标对齐即

可，就是接头处需要注意一下，不要穿帮就行。但是千万别因为简单就小看这个技术哟，上面列表里

面的不少技术都是在循环平铺的基础上发展起来的，下面我们就来瞧一瞧吧。

按照维度的不同，循环平铺有下面三大类：

a.

在一维方向上扩展的横版卷轴游戏（以动作类游戏为主）和纵版卷轴游戏（以射击类游戏为

主）。这些类型的游戏里，为了避免循环平铺给玩家带来的重复的疲劳，卷轴游戏会添加一些随机或

动态的元素，比如超级玛丽里的背景上云朵的位置，分出多个层次以不同速率卷动的背景层，等。

b. 在二维方向上循环平铺的固定视角2D游戏。这一类游戏里，比较典型的就是

Diablo。暗黑中的

随机地图生成，在本质上，就是叠加了一的随机性，约束和边界条件的循环平铺效果。



c\. 在 3D

游戏里循环平铺高度图，形成连绵不断的地形效果。这在早期的模拟飞行射击类游戏里

比较常见，现在已经很难搜到图了，我在上大学的时候写的第一个地形渲染 demo

就是平铺，可惜

刚刚翻硬盘已经找不到了555。这一类游戏，在平铺时适当地辅以一些贴图的变化，可以在很省内存的

条件下，做出非常不错的效果。

找不到游戏内的图，拿下面这个高度图来凑数吧。请大家脑补一下，把下面这个灰度图体化之

后，一块一像地砖一样循环平铺以后，3D渲染出来的连绵起伏的直抵地平线（好吧，直抵远裁剪

面）的山脉的壮观效果吧。



2\. 可预测随机数和无限宇宙（Predictable Random）

（本节内的描述和算法，部分参考了《Game Programming Gems 》 "2.0

Predictable Random

Numbers" 一文，请感兴趣的同学自行查找原文通读）

有个传说中的游戏叫 Elite

，不知道有没有同学玩到过。据说这游戏运行在32K内存的机器上，其

中16K还是只读的ROM。这游戏据说拥有难以匹敌的游戏深度：近乎无限个行星，每一个都有各的名

字和特征。

可预测随机数本身是游戏内运用非常广泛的一个技术，这里我们重谈一下它在为游戏提供（微

观上）更丰富的细节和（宏观上）更广阔的世界的作用。这技术的最重要原则是，为了在一个游戏

世界中给出无限空间的幻觉，我们需要满足个分解条件，可以把它们成为宏无限（macro-infinite）

和微无限（micro-infinite）"。前者涉及到问题的空间规模，后者则任意一个对象所支持的最小细节层

次级别。

从实现上来说，如何设定随机种子是这个技术的核心。由于给定一个随机种子，生成的随机序列

是完全可预测的，那么根据游戏内的一些时空的设定，通过对随机种子进行一些定制，得到在游戏内



任意某个时刻和某个空间点上完全可预测的行为就是可行的了。

最简单的是使用以下几个元素与随机种子配合计算：

世界坐标（即 X Y Z 值，既可以表示空间中的某个点，也可以表示某个区域）

系统时间（可以用真实时间，也可以用游戏内设计者定义的时间，如果是前者的话需要考虑离线

时的处理）

正态分布（在游戏里建一个查找表即可，这是最廉价的案）

这些因素加上对应的随机序列，已经可以营造出宏观上比较有深度的一个宇宙空间了。理论上，

如果所有的随机性都是由给定的随机种子产生，而这些随机种子要么是游戏定义的常量，要么是查表

得到，要么是均匀流逝，要么是由更高层次的随机种子生成，那么这样一层一上溯到尽头的话，任

何一个游戏内的宇宙，都可以归因到一个初始的种子，这个种子，就是决定论中经典物理学的所谓

第一推动吧。其实如果真做到了这一点，我们大可以把这个种子交给玩家，在首次进入游戏的时候掷

一个 2\^64

骰子。这是真正的上帝创世的感觉，想象一下，上帝说，要有光，于是掷出了骰子，第一

推动怦然落地，整个时空的巨大齿轮开始运转，在不同的时间点和空间点上，更多的随机序列被生

出来\...



这幅图来自于游戏 Frontier：Elite

II（出自这篇文章），下面配的字样是："This picture doesn\'t

even bein to show the scale of the universe." 大家感受一下。

微观上本质上也是一样的，只是把发散的过程倒过来，变成了逐级收敛的过程。为了在某一个点

上放大时，能得到尽可能细致，准确和一致的表现，我们需要对较低层次的世界定义更丰富的规则和

约束，比如黑洞对周围的影响情况，双星体系的轨道，恒星的种类与行星个数之间的对应关系，不同

恒星系结构下行星表面的大气构成，等等。这样才能较好地平衡多样性独特性，带来更真实的模拟

效果和更令人信服的游戏体验。

3. 精度问题解决方案

当足够大尺度的世界被创建出来时，就会自然而然地遇到精度的问题。同时这也是补充说明中提

到的一个问题，这里我们简单介绍一下几种实践中的解决方案。

先描述一下问题吧，我们知道，IEEE754

中规定的32位浮点数中，有23位用来表示尾数的。也

就是说，对于接近1的浮点数，可能会带来 2E-24 左的误差（大约是

0.0000001192）以现实单位计

算的话，如果游戏世界是边长为100km的正方形，那么在这个正方形的最远角落里，我们的最小空间

单位是约 7.8

毫米；而如果中国这么大的面积的话，空间误差将达半米左右。那么可以想象一下，

如果是宇宙级别的游戏，采用32位浮点数作为全地图精度，那么实际误差可会有多么大。

在实践中，这种误差可能会带来以下这些影响：

1、无法将相邻的对象对齐。这种情况，场景美术（关卡设计师）应该会比较头疼，这对于游戏的

编辑器来说是大问题了。物件没法在引擎编辑器里对齐；在不同的平台上，对齐也不一样；甚至不同

的编译器，同一个编译器的不同版本编出来的引擎；对齐都不一样 \...

所以说处女座不要做 LD :P。

2、模型间的穿插和裂缝。本来封闭的墙角可能漏个洞，本来放在地上的石头变成了悬浮在空中。

这实际上是上一种的变种。

3、骨骼动画的抖动。由于世界矩阵往往参与骨骼动画的运算，误差可能会被逐级放大，在那些最

远离根骨骼的骨头上（也是玩家最容易注意到的地方），抖动可能会发生得非常剧烈。

4、物理模拟失真。一些柔体的模拟可能会直接失败，而刚体也可能会产生怪异的运动。碰撞系统

也可能无法正常工作。

所有这些一旦发生，都是很容易觉察的。一旦你发现在一个很大的坐标上有这些问题，而接近原

点处问题却消失了，那么很有可能就是精度在作怪。而需要注意的是，出现这种问题，只和游中出



现的数字的规模和跨度有关，和游戏选择了什么样的长度单位（如用毫米还是公里做单位）无关。

那么怎样使用有限的坐标精度来描述较大尺度的世界呢？

最直接的方案是 使用双精度浮点数 （64

位），如果这是可接受的选择，那么就不必费心引入后

面讨论的复杂度了。

其次是 区域划分法 。我看到 Milo

同学已提到，不过这里出于完性的考虑，再简单说一下。正

如 Milo

同学所说，"把世界划分成不同的区域，在区域内的计算使用其局部坐标系统。相对应的跨区

访问，需要对应的"本地A -\> 世界 -\> 地B"的坐标转换。

还有一个方案是：节点中转法。正如移动电话的基站用来承载和协调整个通信网络那样，我们在

游戏的给定活动区域使用静态信标，所有的逻辑上与之相关的单位，都以该信标的坐标作为参考单

位，这样也可以做到数据访问局部化。相距足够远的两个物体（相当于上面的跨区访问）交互总是

通过静态信标来完成（正如移动电话网络中发生的那样），这样的好处是相关的复杂度可以隔绝在这

个中转系统的内部。

此外凯丁同学提到了一个

坐标转换法，"所有位置信息都以角色位置为中心做一次转换"。这正是

《Game Progrmming Gems IV》 "4.0 Solving Accuracy Problems in Large

World Coordinates" 文中

的方案。这个方案可以解决部分问题（主要是渲染相关的问题），但是仍有一些问题需要考虑，比

如：1.

（上面提到的）编辑器内操作的物体，在序列化到文件中时，精度丢失的问题。2.

大部分物理

模拟通常需要一个角色无关，摄像机无关的全局坐标系。等等。

4. 超大地形的处理 （Terrain Visualization）

终于说到对超大地形的处理了。可以说从上世纪九十年代起，超大地形的可视化，一直是3D游戏

领域热门的话题。今天我们就借着这个机会，把相关的算法和实现理一理吧。

考虑到篇幅太长的话，俺的手指头招架不住，再一个不少对这个话题感兴趣的同学可能压根就不

是程序员，一些实现细节可能我就只是简单提一下，贴代码什么的还是算了，尽量保证篇文章的信

息浓度适中吧。

总的来说，这十多年来，地形渲染技术的发展史就是一部生动的对现代GPU的开发，利用和改进

史。整个过程大致可以分成三个阶段：一开始，GPU处理顶点能力很弱，这个时期的各种精巧算法如

一些VDPM和后期的ROAM），尽力在用CPU来降低顶点的总量，避免一不留神压垮图形系统；后来，

图形系统的能力上去了，人们开始更多地考虑到把地形系统融入到通用的场景管理中去，如四叉树八

叉树什么的就是在这个阶段被广泛应用的；再往后，GPU已经很强大了，CPU由于要承担更复杂的游戏



逻辑，越来越成了整个系统的瓶颈，这个阶段，人们琢磨的更多的是，怎么利GPU给CPU减负了，一

直到如今，由 GPGPU 带动起来的异构计算，也都是这个路数。

由于内容比较杂，超大地形这个段落，按上面的描述，咱们分为三个小段分开来讲吧。让俺先

上一杯碧螺春，为客官一一道来。

4.1 古典算法（从 GeoMipMapping，Progressive Mesh 到 ROAM）

GeoMipMapping 是从纹理的 MipMapping

技术演化来的一个地表处理技术，原理上是根据任何一

小块地形在屏幕上显示的实际尺寸（要跟与摄像机的距离和起伏程度有关）来选择对应密度的网

格，然后把不同分辨率的网格之间以某种方式拼接起来（没有这一步的话就会有裂缝），本质上是一

种比较粗糙的区域 LOD

算法。顺便说一下，由于那时候针对顶点级的处理很多，导致这种T型裂缝很

常见，以至于有个专门名字叫"T-Junction"，针对这个的处理在当时也有很多方案。

这是俺刚刚到老硬盘里刨出来的大三时写的 GeoMipMapping

代码，编了一下居然还能跑起来。有

点土，别介意：P 可以看到不同的 MipMap

级别是用不同的颜色渲染的，也可以看到接头处 T 型裂缝

的处理。唉，这代码勾起了俺的青葱回忆啊，那就顺便再来两张 T

型裂缝的示意图和消除过程吧。



Progressive Mesh 是后来很流行的技术 Simplygon

的前身，原理上基本也是一致的，就是以某种

方式渐变性地化简某个给定的 Mesh。

渐进式网格有两种：视点无关的 （View-Indepedent Progressive Mesh，VIPM）

和视点相关的

（View-Dependent Progressive

Mesh，VDPM）。两者的区别就是，前者预先离线生成好所有的渐过

程，运行时直接用就行（也是后来 Simplygon

采用的方案），而后者随着摄像机的位置和角度的变

化，生成应的简化模型。两相对比，VIPM的好处是运行时运算开销低，简化模型的效果好，缺点是

费内存（因为数据都存下来了，当然来增量的方式能省一些），而VDPM在当时是不错的选择，因为

跟VIPM相比不用费额外的内存，而且对于视点（就是摄像机）变化不剧烈的应用，不需要每帧处理和

更新对应的简化模型（普通的MMO类的一般一秒一次就够了），此外由于一些简单的遮挡剔除和背面

剔除，能够比VIPM裁掉多得多的顶点（一般能多裁1/3到一半吧，在当时这可是头等大事）。

总的来说，至少在当时，两者的应用都比较广泛，而到了后来，显存越来越大，总线却越来越紧

张，VDPM这种典型的刷顶点的算法（比较费总线带宽）就逐渐失去了市场，这是后话了。

大家可以在这里看到一些 PM 在地形渲染上的应用。图咱就不上了，大家可以到

Simplygon 的网

站上去看。



ROAM 可算作是上面提到的 VDPM

更进一步了。这个算法实际上借鉴了当时主流引擎的标配BSP

的思路，想利用二叉树这个最简洁的空间描述数据结构，把（CPU端的）顶点消减发挥到极致。整个地

表被组织成一个巨大的二叉树，有两个队列，一个是分割队列，一个是合并队列，分别用于处理摄像

机移动时，增加进入视野的区域细节和消减退出视野的区域细节。精心设计的

ROAM 效果非常华丽

（尤其是在线框模式下），你会看到在各种因素的影响（包括局部坡度，与摄像机的夹角，遮挡情况

等等）下，各种三角形像魔术般的不断地变幻，生成和擦除超多的细节，效果非常魔幻。我印象很深

的是当时连续打Quake3两个小时完全无感的我，调试这玩意的时候，每每不到十分钟眼就花了。

网上找了两张比较典型的 ROAM 大家感受一下吧。



4.2 层次的艺术（Quadtree 和 Chunked LOD）

其实用于空间管理的树状结构有四叉树和八叉树（还有上面的二叉树），但地表通常以前者居

多。是因为，从小范围来看，变化剧烈的地形是3D的，适合八叉树在xyz三个方向上扩展；但当尺度大

到一定规模之后，地形通常退化为相对扁平的2D空间，就像摊平了的地球表面那样，在竖直的Z方向上

变化相对不大，而XY平面则是可能无限延伸的。

Quadtree

四叉树很直白，具体的细节我就不讲了。值得一提的是四叉树往往也同时用于场景管理

的快速剔除和查找，从理论上来讲，四叉树是一个平面上最迅速的用于剔除空间，定位一个物体，内

存开销也是相对较低的数据结构。当用于地形渲染时，顶点剔除的效率也很高，我印象中仅次于高度

优化的

ROAM。内存开销低主要是因为四叉树是可以完美展开到一个位数组里的，这样的话意味着整

个树的利用率达到了百分之百------所有的空间都用来存储数据而不是维持结构。

不过四叉树也不是啥都好，T型裂缝就比 GeoMipMapping

难处理，因为存在跨级的多段 T 缝，如

下图：



除此之外还有一些细节问题，这里就不一一说明了，地形的四叉树渲染还是有很多细节需要细心

处理的，此处暂且放下不表。

Chunked LOD 是一种杂合改良的

LOD，其实糅合了上面说的不少细节，本质上是一种分区块地消

减细节的技术。所谓 Chunk

是批量处理的一种方式，只是一种粒度划分的单位而已，跟现在 Java 的

GC 里分区回收概念上差不多。

下面是典型的 Chunked LOD 后的效果：

顶点多次过滤优化后的效果：



效果在当时还是很惊艳的。通常不到50k的渲染数据量已经能有非常逼真的效果了。

4.3 以GPU为主的技术（从 Paging，Clipmap 到 GPU Terrain）

上面的基本上都是传统方案，这一节我们将逐渐过渡并挨个介绍一下以 GPU

为运算主体的算法。

所谓分页（Paging）实际上是仿效虚拟内存的运行机制的一种方法。由于地表的顶点数据都是静

态数据，适合常驻显存。当世界尺度较大时，显存没法一次放入所有数据，那么系统就像虚拟内存那

样，把那些暂时没有用到的数据交换出去。随着游戏的进行，Paging In/Out

也在不断进行，辅以一定

的异步机制，加载到显存的延迟可以被很好地掩盖。玩家的直观感受就是：哇，海量的细节。



而 Clipmap 则比 Paging

更进一步，以金字塔的形式逐级把数据排列好，直接整体更新和渲染。从

这里也可以看出 GPU 时代人们的思维方式的逐步变迁。从以前顶点级别（Vertex

Level）的"锱铢必

较"，到后来的一次多塞一点也无所谓，只要批次（Batch）少就

OK。下图可以看出 Clipmap 的基本思

路。

所谓的 GPU Terrain Rendering 就是把高度图从内存里经由 2D Vertex Texture

搬到 VS 里去生成

三角面，这样的好处是 CPU

和内存就被彻底解放出来了。只是访问上有一些限制，不像直接处理内存



那样方便。具体的细节可以看这里：GPU Gems 2: Terrain Rendering Using

GPU-Based Geometry

Clipmaps

在 GPU 上做还有个巨大的好处是可以借助 Gaussian Noise

即时生成更多的细节了。直接拿一小块

预生成的高斯噪点图在需要的时候叠加一下，就能在没太大额外开销的情况下，增加各种细节。如下

图所示：

随着大家对 GPU 理解的深入，地形的处理又有很多的小技巧可以做，尤其是在 PS

里面，比如法

线生成，动态uv展开，光照按需叠加/衰减什么的。不过呢据我所知没有什么非常别具一格的架构上的

新思路了，所以就不再深入了。

5. id tech 5 的 megatexture （超大地表上的非重复性海量贴图）

megatexture

在当年（2007）是一个非常值得一提的技术。在这个技术出现之前，几乎所有的地

表渲染用到的贴图都是若干张 blend 到一起后，以 tiling

的形式重复平铺在地表上的（包括比较典型的

魔兽世界也是如此），这样的直接后果是图片的种类用多了耗资源，用少了又很容易感到单调和重

复。而 megatexture

则是一张全局的超大贴图，从根本上避免了重复这个问题，理论上（实践上也

是）能够生成非常壮丽和独特的地质风貌，是传统的刷地表无法创作出的效果。可以说这个技术让真

正的全景地貌成为可能。

技术上的细节puzzy老师写过一个

pdf，强烈推荐感兴趣的同学搜来看一下（可以搜" ID Tech 5

中\"Megatexture\"针对地形的D3D9 基本实现原理 -

姚勇"），珠玉在前，我就不啰嗦了。就来一张效果

图吧（好吧我知道能坚持看到这儿的同学，这图基本上肯定都看过了）



全局超大贴图对一个开放性世界的价值不言而喻。想象一下，跟拿乐高积木拼接出来的视觉效果

（传统的 texture blending and

tiling）相比，一幅万米画卷上，每个像素都可以随意描绘，是一种什

么感受。

比如，你可以相对轻松地实现"整个世界的地貌瞬间被密集核弹蹂躏了一场之后"的效果。如

果你想模拟整个生态环境的变迁，在不同粒度上的整体性修改更是无价之宝。

6. 过程式的内容 （Procedural Content Generation）

"过程式生成"是一个不是很恰当的翻译，实际上更贴近本意的说法是"以程序的手段生成"，这里我

们简洁起见，仍使用过程式生成的字样吧。

过程式的内容生成是随机技术的在视觉效果上的一个重要衍生。这个技术虽然到最近才被广泛应

用，但实际上从技术角度讲，在很久以前就已经有比较成熟的实现了。我手头的

2003 年出版的翻译版

Game Programming Gems III 中 就有 4.16 和 4.17

连续两篇文章以"程序手段生成的纹理"作为主题。

这是构建超大规模的世界的一个重要的技术工具，尤其是与上面的 megatexture

技术结合起来，可以

创造出非常令人震撼的视觉复杂度。

下面是 sourceforge 上一个开源的项目 PCity - Procedural Modeling and

Rendering of Cities



可以看出，对于过程式生成来讲，只要有非常小的初始数据集（meta-data），可以在宏观上达到

很大尺度和复杂度的视觉效果。

过程式生成有两大分支，一个是过程式纹理，另一个是过程式建模（上面的 PCity

属于后者），下

面我们分别来谈一谈。

6.1 过程式纹理（Procedural Texturing）

人们发现，自然界中有很多视觉效果是可以用数学公式加上一些简单的随机性来模拟的，比如云

彩，水流，火焰，木纹，大理石，草地，夜空，大气等等，程序生成的纹理效果大大丰富了普通纹理

能表现的效果，就好像是物理引擎给游戏增加了活力一样。一个普通的噪点图，在不同的情境下，作

为辅助参数来参与生成动态纹理，可以产生出近乎无穷无尽的变化。

这是过程式生成的云，出处在这里。



这是过程式生成的外观，使用了 Allegorithmic 公司的 Substance

Designer，出处在这里

这里是一些分解材质，相当于过程式纹理的图素，出处在这里。



6.2 过程式建模（Procedural Modeling）

过程式建模特指以程序的手段动态建模。这是一个更大的话题，现在比较成熟的中间件的代表是

Speedtree，比如下面这个效果：



完全不同风格的纹理，模型的任意杂合，随意生成，效果也非常真实，非常适合做恐怖游戏。在

Speedtree

的网站上还可以看到长成茶壶的树之类的奇葩。我还记得有一年的GDC，在 IDV

的

Speedtree

的展台看到的一段华丽视频，就是各种藤蔓植物在几秒钟之内长满了一个峡谷内的整个大

坝，电影级的效果非常震撼，不知道现在网上是否还能找到。

过程式建模是一项非常迷人的技术，我本人也曾被深深吸引，在上面投入过一段时间的精力。

2010年时，我在开发一款飞行射击类的 MMO，当时接触到了 Gamr7

的过程式建模技术，感觉很不

错，在飞行类游戏中，地面物体的建模可以完全以程序方式生成，这个对当时的我来说吸引力太大

了。那时我花了一个月把 Gamr7

的技术集成到自己的框架里，并在上海世博会期间，与 Bernard

Légaut 先生 一起在世博会的法国企业馆展示了合作成果。摘两张当时的 PPT

吧。



截图中的素材基本上都是使用了过程式自动生成的（不是美术手放上去的），树是用

speedtree

生成的。

2014-11-18 15:38:14 上传

下载附件 (174.55 KB)

总得来说，过程式建模是一项潜力远远没有得到释放的技术，现有的工具还处于比较原始的阶

段。在当年 PPT 的技术展望（Beyond the

Tech）一节中，我写到"（过程式建模带来的）更高级的抽

象使我们可以控制更高的复杂度，从而带来更丰富的细节 (Higher abstraction

makes much more

details and complexities manageable)

"时至今日，受限于技术的发展，这仍只在某个特定的主题（如

Speedtree

的植被模拟和一般的城市模拟）内有效。对于随机性的粒度，我们仍缺乏有效的手段去控

制。当年展望时的两大

Expectation（一个是建立起模式和库抽象从而满足不同层次上的复用需求，另

一个是如何统一过程式技术中的无序和有序，有效地控制随机性的粒度），现在据我所知仍是所缺甚

多，颇为渺茫。当然了，对有志之士，这也不失为一大探索方向。

